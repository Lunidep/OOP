# Объектно-ориентированное программирование

[lab1](oop_exercise_01) -- Простые классы на языке С++
### Задание:
Вариант 10:
Создать класс Angle для работы с углами на плоскости, задаваемыми
величиной в градусах и минутах. Обязательно должны быть
реализованы: перевод в радианы, приведение к диапазону 0–360,
сложение и вычитание углов, деление углов, получение значений
тригонометрических функций, сравнение углов.

[lab2](oop_exercise_02) -- Перегрузка операторов в С++
### Задание:
Создать класс BitString для работы с 128-битовыми строками.
Битовая строка должна быть представлена двумя полями типа unsigned
long long.
Должны быть реализованы все традиционные операции для работы с
битами: and &, or |, xor ^, not ~.
Реализовать сдвиг влево shiftLeft и сдвиг вправо shiftRight на заданное
количество битов.
Реализовать операцию вычисления количества единичных битов,
операции сравнения по количеству единичных битов.
Реализовать операцию проверки включения.

[lab3](oop_exercise_03) -- Механизмы наследования в С++
### Задание:
Разработать классы согласно варианту задания, классы должны
наследоваться от базового класса Figure

Вариант 20:
1. Трапеция
2. Ромб
3. Пятиугольник

[lab4](oop_exercise_04) -- ...
### Задание:
Необходимо спроектировать и запрограммировать на языке C++ класс-контейнер
первого уровня, содержащий одну фигуру (одна из фигур ЛР3 на выбор). Вариант
структуры данных для контейнера выбрать из документа “Варианты структур
данных” (контейнер 1-го уровня) согласно своему номеру из Варианты ЛР4..

Вариант 18:
18. Бинарное- Дерево Стек


[lab5](oop_exercise_05) -- Основы работы с коллекциями: итераторы
### Задание:
Создать шаблон динамической коллекцию, согласно варианту задания:
1. Коллекция должна быть реализована с помощью умных указателей
(std::shared_ptr, std::weak_ptr). Опционально использование std::unique_ptr;
2. В качестве параметра шаблона коллекция должна принимать тип данных
: шестиугольник;
3. Реализовать forward_iterator по коллекции;
4. Коллекция должны возвращать итераторы begin() и end();
5. Коллекция должна содержать метод вставки на позицию итератора
insert(iterator);
6. Коллекция должна содержать метод удаления из позиции итератора
erase(iterator);
7. При выполнении недопустимых операций (например выход за границы
коллекции или удаление несуществующего элемента) необходимо
генерировать исключения;
8. Итератор должен быть совместим со стандартными алгоритмами
(например, std::count_if)
9. Список должен содержать метод доступа к элементу по оператору [].
10. Реализовать программу, которая:
позволяет вводить с клавиатуры фигуры (с типом int в качестве
параметра шаблона фигуры) и добавлять в коллекцию;
позволяет удалять элемент из коллекции по номеру элемента;
выводит на экран введенные фигуры c помощью std::for_each;
выводит на экран количество объектов, у которых площадь меньше
заданной (с помощью std::count_if)

Варинат 15
Фигура: шестиугольник
Контейнер: список


[lab6](oop_exercise_06) -- Основы работы с коллекциями: аллокаторы
### Задание:
Создать шаблон динамической коллекцию, согласно варианту задания:
1. Коллекция должна быть реализована с помощью умных указателей
(std::shared_ptr, std::weak_ptr). Опционально использование std::unique_ptr.
2. В качестве параметра шаблона коллекция должна принимать тип
данных.
3. Коллекция должна содержать метод доступа:
* Стек – pop, push, top;
* Очередь – pop, push, top;
* Список, Динамический массив – доступ к элементу по оператору [].
4. Реализовать аллокатор, который выделяет фиксированный размер
памяти (количество блоков памяти – является параметром шаблона
аллокатора). Внутри аллокатор должен хранить указатель на используемый
блок памяти и динамическую коллекцию указателей на свободные блоки.
Динамическая коллекция должна соответствовать варианту задания
(Динамический массив, Список, Стек, Очередь).
5. Коллекция должна использовать аллокатор для выделения и
освобождения памяти для своих элементов.
6. Аллокатор должен быть совместим с контейнерами std::map и std::list
(опционально – vector).
7. Реализовать программу, которая:
* позволяет вводить с клавиатуры фигуры (с типом int в качестве
параметра шаблона фигуры) и добавлять в коллекцию использующую
аллокатор;
* позволяет удалять элемент из коллекции по номеру элемента;
* выводит на экран введенные фигуры c помощью std::for_each.

Вариант № 20
Фигура - Трапеция
Контейнер - Очередь
Аллокатор - Очередь

[lab7](oop_exercise_07) -- Простые классы на языке С++
### Задание:
Спроектировать простейший «графический» векторный редактор.
Требования к функционалу редактора:
* создание нового документа
* импорт документа из файла
* экспорт документа в файл
* создание графического примитива (согласно варианту задания)
* удаление графического примитива
* отображение документа на экране (печать перечня графических объектов и их
характеристик в std::cout)
* реализовать операцию undo, отменяющую последнее сделанное действие. Должно
действовать для операций добавления/удаления фигур.
Требования к реализации:
* Создание графических примитивов необходимо вынести в отдельный класс – Factory.
* Сделать упор на использовании полиморфизма при работе с фигурами;
* Взаимодействие с пользователем (ввод команд) реализовать в функции main;

Вариант № 22.
Фигуры: 5 - угольник 6 - угольник 8 - угольник

[lab8](oop_exercise_08) -- Асинхронное программирование
### Задание:
Создать приложение, которое будет считывать из стандартного ввода данные фигур,
согласно варианту задания, выводить их характеристики на экран и записывать в файл.
Программа должна:
1. Осуществлять ввод из стандартного ввода данных фигур, согласно варианту задания;
2. Программа должна создавать классы, соответствующие введенным данных фигур;
3. Программа должна содержать внутренний буфер, в который помещаются фигуры. Для
создания буфера допускается использовать стандартные контейнеры STL. Размер буфера
задается параметром командной строки. Например, для буфера размером 10 фигур:
oop_exercise_08 10;
4. При накоплении буфера они должны запускаться на асинхронную обработку, после чего
буфер должен очищаться;
5. Обработка должна производиться в отдельном потоке;
6. Реализовать два обработчика, которые должны обрабатывать данные буфера:
a. Вывод информации о фигурах в буфере на экран;
b. Вывод информации о фигурах в буфере в файл. Для каждого буфера должен создаваться
файл с уникальным именем.
7. Оба обработчика должны обрабатывать каждый введенный буфер. Т.е. после каждого
заполнения буфера его содержимое должно выводиться как на экран, так и в файл.
8. Обработчики должны быть реализованы в виде лямбда-функций и должны хранится в
специальном массиве обработчиков. Откуда и должны последовательно вызываться в
потоке – обработчике;
9. В программе должно быть ровно два потока (thread). Один основной (main) и второй для
обработчиков;
10. В программе должен явно прослеживаться шаблон Publish-Subscribe. Каждый
обработчик должен быть реализован как отдельный подписчик;
11. Реализовать в основном потоке (main) ожидание обработки буфера в потокеобработчике. Т.е. после отправки буфера на обработку основной поток должен ждать,
пока поток обработчик выведет данные на экран и запишет в файл.

Вариант № 24
Фигуры: квадрат, треугольник, 8-угольник
&emsp;<br />
